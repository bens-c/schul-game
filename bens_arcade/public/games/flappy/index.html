<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy — verbessert</title>
<style>
  *{margin:0;padding:0}
  html,body{width:100%;height:100%;background:#70c5ce;display:flex;align-items:center;justify-content:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{width:100%;height:100%;display:flex;align-items:center;justify-content:center}
  canvas{display:block;background:linear-gradient(#70c5ce,#4aaec0);border:4px solid #0b5670;box-shadow:0 6px 18px rgba(0,0,0,0.25)}
  .ui{
    position:fixed;
    left:50%;
    top:12px;
    transform:translateX(-50%);
    color:#023;
    font-weight:600;
    text-shadow:0 1px 0 #fff7;
    text-align:center;
    z-index:10;
    pointer-events:none;
  }
  .hint{
    position:fixed;
    left:50%;
    top:52px;
    transform:translateX(-50%);
    color:#023;
    opacity:.95;
    text-align:center;
    z-index:10;
    pointer-events:none;
  }
  .back-btn{
    position:fixed;
    top:12px;
    right:12px;
    left:auto;
    transform:none;
    padding:8px 12px;
    border-radius:8px;
    border:2px solid rgba(0,0,0,0.12);
    background:rgba(255,255,255,0.98);
    color:#023;
    font-weight:700;
    cursor:pointer;
    z-index:20;
    box-shadow:0 4px 12px rgba(0,0,0,0.12);
    pointer-events:auto;
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>
<div class="ui" id="scoreDisplay">Score: 0 | Best: 0</div>
<div class="hint" id="hint">Tippen / Klicken / Leertaste zum Springen</div>
<button id="backBtn" class="back-btn" type="button" aria-label="Zurück">Zurück</button>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const hint = document.getElementById('hint');
  const backBtn = document.getElementById('backBtn');

  // Helper: current CSS-size (drawing code uses CSS pixels because of setTransform)
  function cssWidth(){ return canvas.width / Math.max(1, window.devicePixelRatio || 1); }
  function cssHeight(){ return canvas.height / Math.max(1, window.devicePixelRatio || 1); }
  
  // HiDPI scaling
  function resize() {
    const ratio = Math.max(1, window.devicePixelRatio || 1);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    canvas.width = Math.floor(window.innerWidth * ratio);
    canvas.height = Math.floor(window.innerHeight * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }
  window.addEventListener('resize', () => { resize(); });
  resize();

  // Game state
  let lastTime = performance.now();
  let running = false;
  let gameOver = false;
  let started = false;

  // Bird
  const bird = {
    x: 140,
    y: canvas.height / 4,
    w: 34,
    h: 24,
    vy: 0,
    gravity: 1100,
    jumpImpulse: -320,
    maxFall: 900
  };

  // Pipes
  const pipes = [];
  const pipeSpeed = 200;
  const pipeGap = 150;
  const pipeWidth = 78;
  let spawnTimer = 0;
  const spawnInterval = 1500; // ms

  // Score
  let score = 0;
  const highKey = 'flappy_high';
  let best = parseInt(localStorage.getItem(highKey) || '0', 10);

  function reset() {
    pipes.length = 0;
    bird.y = cssHeight() / 2;
    bird.vy = 0;
    score = 0;
    spawnTimer = 0;
    gameOver = false;
    started = false;
    updateHUD();
  }

  function updateHUD(){
    scoreDisplay.textContent = `Score: ${score} | Best: ${best}`;
  }

  function spawnPipe() {
    const margin = 60;
    const available = cssHeight() - margin*2 - pipeGap;
    const top = margin + Math.random() * Math.max(0, available);
    pipes.push({ x: cssWidth() + pipeWidth, top: top });
  }

  function rectsIntersect(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function checkCollision(){
    // ground / ceiling
    if (bird.y < 0 || bird.y + bird.h > canvas.height) return true;
    for (const p of pipes) {
      const topRect = { x: p.x, y: 0, w: pipeWidth, h: p.top };
      const bottomRect = { x: p.x, y: p.top + pipeGap, w: pipeWidth, h: canvas.height - (p.top + pipeGap) };
      if (rectsIntersect(bird.x, bird.y, bird.w, bird.h, topRect.x, topRect.y, topRect.w, topRect.h)) return true;
      if (rectsIntersect(bird.x, bird.y, bird.w, bird.h, bottomRect.x, bottomRect.y, bottomRect.w, bottomRect.h)) return true;
    }
    return false;
  }

  function sendScore() {
    // send only if score positive
    if (score <= 0) return;
    fetch('/score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': localStorage.token || ''
      },
      body: JSON.stringify({ game: 'flappy', score })
    }).catch(()=>{ /* ignore network errors */ });
  }

  function onJump() {
    if (gameOver) { reset(); return; }
    started = true;
    bird.vy = bird.jumpImpulse;
    running = true;
  }

  // Input
  window.addEventListener('keydown', e => {
    if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); onJump(); }
    if (e.key === 'r' && gameOver) reset();
    if (e.key === 'Escape') {
      // Escape = zurück: versuche Referrer, sonst history.back(), sonst close
      if (document.referrer) location.href = document.referrer;
      else if (window.history.length > 1) history.back();
      else window.close();
    }
  });
  window.addEventListener('mousedown', onJump);
  window.addEventListener('touchstart', e => { e.preventDefault(); onJump(); }, {passive:false});

  // Back button behavior: prefer referrer, fallback to history.back()
  if (backBtn) {
    backBtn.addEventListener('click', () => {
      if (document.referrer) location.href = document.referrer;
      else if (window.history.length > 1) history.back();
      else {
        // Fallback: inform user (window.close may be blocked)
        hint.textContent = 'Kein Verlauf gefunden — $BROWSER file:///workspaces/schul-game/bens_arcade/public/';
      }
    });
  }

  // Main loop
  function loop(now) {
    const dt = Math.min(0.05, (now - lastTime) / 1000);
    lastTime = now;
    if (running) step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function step(dt) {
    // physics
    bird.vy += bird.gravity * dt;
    bird.vy = Math.min(bird.vy, bird.maxFall);
    bird.y += bird.vy * dt;

    // pipes movement & spawn
    spawnTimer += dt * 1000;
    if (spawnTimer >= spawnInterval) { spawnTimer -= spawnInterval; spawnPipe(); }
    for (let i = pipes.length -1; i >= 0; i--) {
      pipes[i].x -= pipeSpeed * dt;
      if (pipes[i].x + pipeWidth < 0) pipes.splice(i,1);
      else {
        // scoring when pipe passes bird
        if (!pipes[i].scored && pipes[i].x + pipeWidth < bird.x) {
          pipes[i].scored = true;
          score++;
          if (score > best) { best = score; localStorage.setItem(highKey, best); }
          updateHUD();
        }
      }
    }

    // collision
    if (checkCollision()) {
      gameOver = true;
      running = false;
      sendScore();
      hint.textContent = 'Game Over — Klick/Tippen zum Neustart';
    } else {
      hint.textContent = 'Tippen / Klicken / Leertaste zum Springen';
    }
  }

  function draw() {
    // use CSS sizes for layout so centering (canvas.clientWidth) matches drawing coordinates
    const cw = cssWidth();
    const ch = cssHeight();
    ctx.clearRect(0,0,cw,ch);

    // background simple ground
    const skyH = ch * 0.75;
    ctx.fillStyle = '#70c5ce';
    ctx.fillRect(0,0,cw,skyH);
    ctx.fillStyle = '#6ad3b8';
    ctx.fillRect(0,skyH,cw,ch - skyH);

    // pipes
    for (const p of pipes) {
      ctx.fillStyle = '#2c9a4d';
      // top
      ctx.fillRect(p.x, 0, pipeWidth, p.top);
      // bottom
      ctx.fillRect(p.x, p.top + pipeGap, pipeWidth, canvas.height - (p.top + pipeGap));
      // pipe rim
      ctx.fillStyle = '#1f6b3b';
      ctx.fillRect(p.x, p.top - 8, pipeWidth, 8);
      ctx.fillRect(p.x, p.top + pipeGap, pipeWidth, 8);
    }

    // bird (simple rectangle with rotation)
    ctx.save();
    const centerX = bird.x + bird.w/2;
    const centerY = bird.y + bird.h/2;
    const tilt = Math.max(-0.6, Math.min(0.8, bird.vy / 600));
    ctx.translate(centerX, centerY);
    ctx.rotate(tilt);
    ctx.fillStyle = '#ffbb33';
    ctx.fillRect(-bird.w/2, -bird.h/2, bird.w, bird.h);
    // eye
    ctx.fillStyle = '#111';
    ctx.fillRect(bird.w*0.1 - bird.w/2, -bird.h*0.15, bird.w*0.18, bird.h*0.18);
    ctx.restore();

    // HUD (score big)
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.font = 'bold 32px system-ui, sans-serif';
    ctx.fillText(score, 20, 46);

    if (!started) {
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '28px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Klicken / Tippen / Leertaste zum Starten', cw/2, ch*0.4);
      ctx.textAlign = 'left';
    }

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0, ch*0.28, cw, ch*0.44);
      ctx.fillStyle = '#fff';
      ctx.font = '36px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', cw/2, ch*0.45);
      ctx.font = '22px system-ui, sans-serif';
      ctx.fillText(`Score: ${score}  —  Best: ${best}`, cw/2, ch*0.52);
      ctx.fillText('Klicken/Tippen zum Neustarten', cw/2, ch*0.60);
      ctx.textAlign = 'left';
    }
  }

  // start loop
  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
